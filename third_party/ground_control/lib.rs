//! Process manager designed for container-*like* environments that need
//! to run multiple processes, with basic dependency relationships and
//! pre/post execution commands.

#![forbid(unsafe_code, future_incompatible)]
#![deny(
    missing_debug_implementations,
    nonstandard_style,
    missing_docs,
    unreachable_pub,
    missing_copy_implementations,
    unused_qualifications,
    clippy::unwrap_in_result,
    clippy::unwrap_used
)]

use color_eyre::eyre;
use config::Config;
use tokio::sync::mpsc;

use crate::process::Process;

mod command;
pub mod config;
pub mod formatter;
mod process;

/// Errors generated by Ground Control.
#[derive(Debug, thiserror::Error)]
pub enum Error {
    /// A process failed to start and the startup process was aborted.
    #[error("Startup aborted")]
    StartupAborted(#[from] eyre::Report),

    /// A long-running daemon exited with a non-zero exit code.
    #[error("Daemon process exited with a non-zero exit code")]
    AbnormalShutdown,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum ShutdownReason {
    /// Graceful shutdown was triggered by an external signal.
    GracefulShutdown,

    /// Daemon exited cleanly.
    DaemonExited,

    /// Daemon failed (non-zero exit code).
    DaemonFailed,
}

/// Runs a Ground Control specification, returning only when all of the
/// processes have stopped (either because one process triggered a
/// shutdown, or because the `shutdown` signal was triggered).
pub async fn run(config: Config, mut shutdown: mpsc::UnboundedReceiver<()>) -> Result<(), Error> {
    tracing::info!("Ground Control starting.");

    // Create the shutdown channel, which will be used to initiate the
    // shutdown process, regardless of if this is a graceful shutdown
    // triggered by a shutdown signal, a clean shutdown of a daemon
    // process, or an unexpected shutdown caused by the failure of a
    // daemon process.
    let (shutdown_sender, mut shutdown_receiver) = mpsc::unbounded_channel::<ShutdownReason>();

    // Set extra environment variables.
    for (key, value) in &config.env {
        std::env::set_var(key, value);
    }

    // Start every process in the order they were found in the config
    // file.
    let mut running: Vec<Process> = Vec::with_capacity(config.processes.len());
    for process_config in config.processes.into_iter() {
        let process = match process::start_process(process_config, shutdown_sender.clone()).await {
            Ok(process) => process,
            Err(err) => {
                tracing::error!(?err, "Failed to start process; aborting startup procedure");

                // Stop all of the daemon processes that have already
                // started (otherwise they will block Ground Control
                // from exiting and thus the container from shutting
                // down).
                while let Some(process) = running.pop() {
                    if let Err(err) = process.stop_process().await {
                        tracing::error!(?err, "Error stopping process after aborted startup");
                    }
                }

                // Manually drop `shutdown_sender` here, and then drain
                // all of the receiver signals. If we let the channel
                // auto-drop (which happens at the entrance to this
                // match arm), then stopping the already-started
                // processes will generate a bunch of spurious errors,
                // since they will be unable to send their shutdown
                // signals. That also generates out-of-order log lines,
                // since the warnings about those signals may not show
                // up until *after* Ground Control itself thinks it has
                // stopped.
                drop(shutdown_sender);
                while shutdown_receiver.recv().await.is_some() {}

                // Return the original error, now that everything has
                // been stopped.
                return Err(Error::StartupAborted(err));
            }
        };

        running.push(process);
    }

    // Convert an external shutdown signal into a shutdown message.
    let external_shutdown_sender = shutdown_sender.clone();
    tokio::spawn(async move {
        // Both sending the shutdown signal, *and dropping the sender,*
        // trigger a shutdown.
        let _ = shutdown.recv().await;
        let _ = external_shutdown_sender.send(ShutdownReason::GracefulShutdown);
    });

    tracing::info!("Startup phase completed; waiting for shutdown signal or any process to exit.");

    let shutdown_reason = shutdown_receiver
        .recv()
        .await
        .expect("All shutdown senders closed without sending a shutdown signal.");

    // Either one process exited or we received a stop signal; stop all
    // of the processes in the *reverse* order in which they were
    // started. Note that "stop" means both `stop` (*if* the process is
    // a daemon process that is still running) and `post`.
    tracing::info!("Completion signal triggered; shutting down all processes");

    while let Some(process) = running.pop() {
        if let Err(err) = process.stop_process().await {
            tracing::error!(?err, "Error stopping process");
        }
    }

    tracing::info!("All processes have exited; Ground Control shutting down.");

    // Clean shutdowns (a daemon that exited with a non-error exit code,
    // or a graceful shutdown request) are success, abnormal shutdowns
    // are errors.
    match shutdown_reason {
        ShutdownReason::GracefulShutdown | ShutdownReason::DaemonExited => Ok(()),
        ShutdownReason::DaemonFailed => Err(Error::AbnormalShutdown),
    }
}
